'use strict';

const assert = require('assert');

const Categories = require('../src/categories');
const apiCategories = require('../src/api/categories');
const User = require('../src/user');
const groups = require('../src/groups');
const db = require('./mocks/databasemock');
const nconf = require('nconf');
const request = require('../src/request');
const helpers = require('./helpers');
const privileges = require('../src/privileges');
const Topics = require('../src/topics');

// Code partially generated by Copilot and ChatGPT-5 mini
describe('Category owner create and delete', () => {
	let ownerUid;
	let otherUid;
	let adminUid;
	let ownerName;
	let otherName;
	let adminName;
	let createdCategory;

	// Small helpers used only in this test file
	async function registerOrCreate(username) {
		const reg = await helpers.registerUser({ username, password: 'password', email: `${username}@example.org` }).catch(() => null);
		if (reg && reg.body && reg.body.uid) {
			return reg.body.uid;
		}
		return await User.create({ username, password: 'password', email: `${username}@example.org` });
	}

	async function loginJar(username) {
		// helpers.loginUser returns { jar }
		const result = await helpers.loginUser(username, 'password').catch(() => helpers.loginUser(username, 'password'));
		return result.jar;
	}

	before(async () => {
		ownerName = `owner_${Date.now()}`;
		otherName = `other_${Date.now()}`;
		adminName = `admin_${Date.now()}`;

		ownerUid = await registerOrCreate(ownerName);
		otherUid = await registerOrCreate(otherName);
		adminUid = await registerOrCreate(adminName);
		await groups.join('administrators', adminUid);

		// avoid throttle/new-user blocks
		await User.setUserField(ownerUid, 'joindate', Date.now() - (3600 * 1000));
		await User.setUserField(otherUid, 'joindate', Date.now() - (3600 * 1000));
		await User.setUserField(adminUid, 'joindate', Date.now() - (3600 * 1000));

		// Remove any leftover test categories from previous runs
		const allCategories = await Categories.getAllCategories();
		const categoriesToDelete = allCategories
			.filter(category => category.name === 'Integration Owner Cat')
			.map(category => Categories.purge(category.cid, adminUid));
		await Promise.all(categoriesToDelete);
	});

	after(async () => {
		// Cleanup any remaining test categories
		const allCategories = await Categories.getAllCategories();
		const categoriesToDelete = allCategories
			.filter(category => category.name === 'Integration Owner Cat')
			.map(category => Categories.purge(category.cid, adminUid));
		await Promise.all(categoriesToDelete);
	});


	it('should allow authenticated user to create a category and becomes its owner', async () => {
		createdCategory = await apiCategories.create({ uid: ownerUid }, {
			name: 'Integration Owner Cat',
			description: 'Created by integration test',
		});
		assert(createdCategory);
		assert.equal(createdCategory.name, 'Integration Owner Cat');
		assert.equal(createdCategory.description, 'Created by integration test');
		
		// Verify the category exists in the database
		const categoryData = await Categories.getCategoryData(createdCategory.cid);
		assert(categoryData);
		assert.equal(categoryData.name, 'Integration Owner Cat');
		assert.equal(categoryData.uid, ownerUid);
	});

	it('should not allow non-owner to delete; owner and allow admin to delete', async () => {
		// Verify non-owner cannot delete
		try {
			await apiCategories.delete({ uid: otherUid }, { cid: createdCategory.cid });
			assert.fail('Should have thrown error');
		} catch (err) {
			assert.equal(err.message, '[[error:no-privileges]]');
		}

		// Verify category still exists
		let category = await Categories.getCategoryData(createdCategory.cid);
		assert(category);
		assert.equal(category.name, 'Integration Owner Cat');

		// Verify owner can delete
		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: createdCategory.cid });
		category = await Categories.getCategoryData(createdCategory.cid);
		assert(!category);

		// Create new category for admin delete test
		createdCategory = await apiCategories.create({ uid: ownerUid }, {
			name: 'Integration Owner Cat',
			description: 'Created by integration test',
		});
		assert(createdCategory);

		// Verify admin can delete
		await apiCategories.delete({ uid: adminUid, ip: '127.0.0.1' }, { cid: createdCategory.cid });
		category = await Categories.getCategoryData(createdCategory.cid);
		assert(!category);
	});

	it('should expose allowPurge in the categories page for owner and admin but not for student', async () => {
		// Ensure createdCategory exists
		createdCategory = await apiCategories.create({ uid: ownerUid }, {
			name: 'Integration Owner Cat',
			description: 'Created by integration test',
		});

		// Use apiCategories.list to fetch categories visible to the owner
		const ownerData = await apiCategories.list({ uid: ownerUid });
		assert(ownerData);
		// per-category flag (purgable) should be true for owner
		const found = ownerData.categories.find(c => c.cid === createdCategory.cid);
		assert(found, 'created category not present in categories list');
		// Student (guest) should not see per-category purging allowed
		const guestData = await apiCategories.list({ uid: 0 });
		const guestFound = guestData.categories.find(c => c.cid === createdCategory.cid);
		assert(guestFound, 'created category missing for guest view');
		const guestHasGlobal = await privileges.global.can('category:purge', 0);
		const guestIsOwner = guestFound.uid && parseInt(guestFound.uid, 10) === 0;
		assert.strictEqual(Boolean(guestHasGlobal || guestIsOwner), false, 'guest should not be able to purge');

		// Admin should be able to purge via API
		const adminData = await apiCategories.list({ uid: adminUid });
		const adminFound = adminData.categories.find(c => c.cid === createdCategory.cid);
		assert(adminFound, 'created category missing for admin view');
		const adminHasGlobal = await privileges.global.can('category:purge', adminUid);
		assert.strictEqual(Boolean(adminHasGlobal), true, 'admin should be allowed to purge');

	});

	it('should allow owner to delete category with data in it', async () => {
		// Create a fresh category and a topic inside it
		createdCategory = await apiCategories.create({ uid: ownerUid }, {
			name: 'Integration Owner Cat',
			description: 'Category with a topic to be deleted by owner',
		});
		assert(createdCategory && createdCategory.cid, 'createdCategory must exist');

		const { topicData } = await Topics.post({
			uid: ownerUid,
			cid: createdCategory.cid,
			title: 'Integration topic inside category',
			content: 'OP content to ensure category contains data',
		});
		assert(topicData && topicData.tid, 'topic should be created in category');

		// Owner deletes the category (should succeed even if there are topics)
		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: createdCategory.cid });

		// Category removed
		const category = await Categories.getCategoryData(createdCategory.cid);
		assert(!category, 'category should be removed from DB after delete by owner');

		// Topics under the category should also be cleaned up (topic lookup should return null)
		const topicAfter = await Topics.getTopicData(topicData.tid);
		assert(!topicAfter, 'topic should not exist after category delete');
	});

	it('should return clear error for non-existent cid via controller', async () => {
		// try deleting a cid that doesn't exist
		const fakeCid = 9999999;
		try {
			await helpers.request('DELETE', `/api/v3/categories/${fakeCid}`, { jar: request.jar() });
			assert.fail('Should have thrown');
		} catch (err) {
			// expect an API error response
			assert(err && (err.message || err.body), 'expected error message or body');
		}
	});

	it('should return bad request for invalid cid format', async () => {
		const jar = request.jar();
		try {
			await helpers.request('DELETE', `/api/v3/categories/not-a-number`, { jar });
			assert.fail('Should have thrown');
		} catch (err) {
			assert(err, 'expected error for invalid cid');
		}
	});

	it('owner and admin permission checks via controller', async () => {
		// create category as owner
		createdCategory = await apiCategories.create({ uid: ownerUid }, { name: 'Integration Owner Cat', description: 'perm checks' });
		assert(createdCategory && createdCategory.cid);

		// non-owner via HTTP should get 403/no-privileges
		const { jar: otherJar } = await helpers.loginUser(otherName, 'password').catch(async () => {
			// fallback: login using stored username
			return await helpers.loginUser(otherName, 'password');
		});
		const { response: res1 } = await helpers.request('DELETE', `/api/v3/categories/${createdCategory.cid}`, { jar: otherJar }).catch(e => ({ response: e.response || {} }));
		assert(res1 && (res1.status === 401 || res1.status === 403));

		// create again and let admin delete via HTTP (owner deletion checked in lower-level API tests)
		createdCategory = await apiCategories.create({ uid: ownerUid }, { name: 'Integration Owner Cat', description: 'perm checks admin' });

		const { jar: adminJar } = await helpers.loginUser(adminName, 'password');
		const { response: res3 } = await helpers.request('DELETE', `/api/v3/categories/${createdCategory.cid}`, { jar: adminJar }).catch(e => ({ response: e.response || {} }));
		assert(res3 && res3.status === 200);
	});

	it('deleting a parent category purges children', async () => {
		// create parent and child
		const parent = await apiCategories.create({ uid: ownerUid }, { name: 'Integration Owner Cat', description: 'parent' });
		const child = await apiCategories.create({ uid: ownerUid }, { name: 'Integration Child Cat', description: 'child', parentCid: parent.cid });
		assert(parent && parent.cid && child && child.cid);

		// create a topic in child to ensure child has data
		const { topicData } = await Topics.post({ uid: ownerUid, cid: child.cid, title: 'child topic', content: 'child content' });

		// delete parent
		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: parent.cid });

		// parent should be removed; child should be reparented to root (parentCid === 0)
		const p = await Categories.getCategoryData(parent.cid);
		const c = await Categories.getCategoryData(child.cid);
		assert(!p, 'parent should be removed');
		assert(c && parseInt(c.parentCid, 10) === 0, 'child should be reparented to root (parentCid === 0)');

		// topic under the child should remain (child was not purged)
		const t = await Topics.getTopicData(topicData.tid);
		assert(t, 'topic under child should still exist after parent deletion');
	});

	it('pinned and scheduled topics are purged when category deleted', async () => {
		const cat = await apiCategories.create({ uid: ownerUid }, { name: 'Integration Owner Cat', description: 'pinned test' });

		// create pinned topic (content must meet minimum length)

		const { topicData: pinned } = await Topics.post({ uid: ownerUid, cid: cat.cid, title: 'pinned topic', content: 'This is a pinned topic content used for testing purge behavior and is sufficiently long.' });
		await Topics.setTopicField(pinned.tid, 'pinned', 1);

		// create scheduled topic (future timestamp)

		const futureTid = await Topics.create({ uid: ownerUid, cid: cat.cid, title: 'scheduled topic', content: 'Scheduled topic content for purge test', timestamp: Date.now() + (1000 * 60 * 60) });

		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: cat.cid });

		const p = await Topics.getTopicData(pinned.tid);
		const s = await Topics.getTopicData(futureTid);
		assert(!p && !s, 'pinned and scheduled topics should be removed');
	});

	it('topics with flagged posts resolve flags on purge', async () => {
		const cat = await apiCategories.create({ uid: ownerUid }, { name: 'Integration Owner Cat', description: 'flags test' });
		const { postData } = await Topics.post({ uid: ownerUid, cid: cat.cid, title: 'flag topic', content: 'flag content' });
		// create a flag on the post (Flags.create returns a flag object)
		const flagObj = await require('../src/flags').create('post', postData.pid, otherUid, 'test flag');
		// delete category
		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: cat.cid });
		// check that flag is resolved
		const flag = await require('../src/flags').get(flagObj.flagId);
		assert(flag && flag.state === 'resolved');
	});

	it('should delete category via API and persist removal after refresh', async () => {
		// create a fresh category
		const cat = await apiCategories.create({ uid: ownerUid }, { name: `Integration Persist Cat ${Date.now()}`, description: 'for persistence test' });
		assert(cat && cat.cid);

		// Owner deletes via API (simulating the confirmation acceptance)
		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: cat.cid });

		// Confirm DB removed
		const category = await Categories.getCategoryData(cat.cid);
		assert(!category, 'category should be removed from DB');

		// Refresh via API categories list
		const refreshed = await apiCategories.list({ uid: ownerUid });
		const stillThere = refreshed.categories.find(c => c.cid === cat.cid);
		assert(!stillThere, 'category should not appear after refresh');
	});
});