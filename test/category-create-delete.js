'use strict';

const assert = require('assert');

const Categories = require('../src/categories');
const apiCategories = require('../src/api/categories');
const User = require('../src/user');
const groups = require('../src/groups');
const db = require('./mocks/databasemock');
const nconf = require('nconf');
const request = require('../src/request');
const helpers = require('./helpers');
const privileges = require('../src/privileges');

// Code partially generated by Copilot and ChatGPT-5 mini
describe('Category owner create and delete', () => {
	let ownerUid;
	let otherUid;
	let adminUid;
	let createdCategory;

	before(async () => {
		ownerUid = await User.create({ username: `owner_${Date.now()}` });
		otherUid = await User.create({ username: `other_${Date.now()}` });
		adminUid = await User.create({ username: `admin_${Date.now()}` });
		await groups.join('administrators', adminUid);

		// avoid throttle/new-user blocks
		await User.setUserField(ownerUid, 'joindate', Date.now() - (3600 * 1000));
		await User.setUserField(otherUid, 'joindate', Date.now() - (3600 * 1000));
		await User.setUserField(adminUid, 'joindate', Date.now() - (3600 * 1000));
	});

	before(async () => {
		// Delete any existing test categories
		const allCategories = await Categories.getAllCategories();
		const categoriesToDelete = allCategories
			.filter(category => category.name === 'Integration Owner Cat')
			.map(category => Categories.purge(category.cid, adminUid));
		await Promise.all(categoriesToDelete);
	});

	after(async () => {
		// Cleanup any remaining test categories
		const allCategories = await Categories.getAllCategories();
		const categoriesToDelete = allCategories
			.filter(category => category.name === 'Integration Owner Cat')
			.map(category => Categories.purge(category.cid, adminUid));
		await Promise.all(categoriesToDelete);
	});

	it('should allow authenticated user to create a category and becomes its owner', async () => {
		createdCategory = await apiCategories.create({ uid: ownerUid }, {
			name: 'Integration Owner Cat',
			description: 'Created by integration test',
		});
		assert(createdCategory);
		assert.equal(createdCategory.name, 'Integration Owner Cat');
		assert.equal(createdCategory.description, 'Created by integration test');
		
		// Verify the category exists in the database
		const categoryData = await Categories.getCategoryData(createdCategory.cid);
		assert(categoryData);
		assert.equal(categoryData.name, 'Integration Owner Cat');
		assert.equal(categoryData.uid, ownerUid);
	});

	it('should not allow non-owner to delete; owner and allow admin to delete', async () => {
		// Verify non-owner cannot delete
		try {
			await apiCategories.delete({ uid: otherUid }, { cid: createdCategory.cid });
			assert.fail('Should have thrown error');
		} catch (err) {
			assert.equal(err.message, '[[error:no-privileges]]');
		}

		// Verify category still exists
		let category = await Categories.getCategoryData(createdCategory.cid);
		assert(category);
		assert.equal(category.name, 'Integration Owner Cat');

		// Verify owner can delete
		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: createdCategory.cid });
		category = await Categories.getCategoryData(createdCategory.cid);
		assert(!category);

		// Create new category for admin delete test
		createdCategory = await apiCategories.create({ uid: ownerUid }, {
			name: 'Integration Owner Cat',
			description: 'Created by integration test',
		});
		assert(createdCategory);

		// Verify admin can delete
		await apiCategories.delete({ uid: adminUid, ip: '127.0.0.1' }, { cid: createdCategory.cid });
		category = await Categories.getCategoryData(createdCategory.cid);
		assert(!category);
	});

	it('should expose allowPurge in the categories page for owner and admin but not for student', async () => {
		// Ensure createdCategory exists
		createdCategory = await apiCategories.create({ uid: ownerUid }, {
			name: 'Integration Owner Cat',
			description: 'Created by integration test',
		});

		// Use apiCategories.list to fetch categories visible to the owner
		const ownerData = await apiCategories.list({ uid: ownerUid });
		assert(ownerData);
		// per-category flag (purgable) should be true for owner
		const found = ownerData.categories.find(c => c.cid === createdCategory.cid);
		assert(found, 'created category not present in categories list');
		// Owner should be allowed to purge if they are the category owner OR have the global purge privilege
		const ownerHasGlobal = await privileges.global.can('category:purge', ownerUid);
		const ownerIsOwner = found.uid && parseInt(found.uid, 10) === parseInt(ownerUid, 10);
		assert.strictEqual(Boolean(ownerHasGlobal || ownerIsOwner), true, 'owner should be allowed to purge');

		// Student (guest) should not see per-category purging allowed
		const guestData = await apiCategories.list({ uid: 0 });
		const guestFound = guestData.categories.find(c => c.cid === createdCategory.cid);
		assert(guestFound, 'created category missing for guest view');
		const guestHasGlobal = await privileges.global.can('category:purge', 0);
		const guestIsOwner = guestFound.uid && parseInt(guestFound.uid, 10) === 0;
		assert.strictEqual(Boolean(guestHasGlobal || guestIsOwner), false, 'guest should not be able to purge');

		// Admin should be able to purge via API
		const adminData = await apiCategories.list({ uid: adminUid });
		const adminFound = adminData.categories.find(c => c.cid === createdCategory.cid);
		assert(adminFound, 'created category missing for admin view');
		const adminHasGlobal = await privileges.global.can('category:purge', adminUid);
		const adminIsOwner = adminFound.uid && parseInt(adminFound.uid, 10) === parseInt(adminUid, 10);
		assert.strictEqual(Boolean(adminHasGlobal || adminIsOwner), true, 'admin should be allowed to purge');

	});

	it('should delete category via API and persist removal after refresh', async () => {
		// create a fresh category
		const cat = await apiCategories.create({ uid: ownerUid }, { name: `Integration Persist Cat ${Date.now()}`, description: 'for persistence test' });
		assert(cat && cat.cid);

		// Owner deletes via API (simulating the confirmation acceptance)
		await apiCategories.delete({ uid: ownerUid, ip: '127.0.0.1' }, { cid: cat.cid });

		// Confirm DB removed
		const category = await Categories.getCategoryData(cat.cid);
		assert(!category, 'category should be removed from DB');

		// Refresh via API categories list
		const refreshed = await apiCategories.list({ uid: ownerUid });
		const stillThere = refreshed.categories.find(c => c.cid === cat.cid);
		assert(!stillThere, 'category should not appear after refresh');
	});
});